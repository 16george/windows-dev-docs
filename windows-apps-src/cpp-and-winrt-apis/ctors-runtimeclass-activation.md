---
author: stevewhims
description: This topic describes essential concepts and terms that support your understanding of how to consume and author runtime classes with C++/WinRT.
title: Implementation and projected types for a C++/WinRT runtime class
ms.author: stwhi
ms.date: 03/05/2018
ms.topic: article
ms.prod: windows
ms.technology: uwp
keywords: windows 10, uwp, standard, c++, cpp, winrt, projected, projection, implementation, runtime class, activation
ms.localizationpriority: medium
---

# Implementation and projected types for a C++/WinRT runtime class
> [!NOTE]
> **Some information relates to pre-released product which may be substantially modified before itâ€™s commercially released. Microsoft makes no warranties, express or implied, with respect to the information provided here.**

This topic describes essential concepts and terms that support your understanding of how to consume and author runtime classes with C++/WinRT.

## Concepts and terminology
Let's introduce an example project so that we have a context in which to put these important concepts and terms. Imagine that your project name (and therefore your root namespace name) is MyProject. We recommend that you declare each runtime class in its own Interface Definition Language (IDL) (`.idl`) file. Here's an example.

```idl
// MyRuntimeClass.idl
import "Windows.Foundation.idl";

namespace MyProject
{
	runtimeclass MyRuntimeClass
	{
		MyRuntimeClass(); // A constructor makes the runtime class activatable from outside the compilation unit.
		String Name;
	}
}
```

This IDL declares a Windows Runtime (runtime) class. A runtime class is a type that can be activated and consumed via modern COM interfaces, typically across executable boundaries (but a runtime class can also be used within the compilation unit that implements it). From this IDL, the C++/WinRT toolchain generates an implementation type and a projected type, which are described in the summary below. An important point to take away from this summary is that saying only "**MyRuntimeClass**" may be ambiguous; there are several entities with that name, of different kinds.

- **MyRuntimeClass** is the name of a runtime class, declared in IDL.
- **MyRuntimeClass** is also the name of the C++ struct `winrt::MyProject::implementation::MyRuntimeClass`, which is the C++ implementation of the runtime class. If there are separate implementing and consuming projects, then this struct exists only in the implementing project. We'll call this type *the implementation type*, or *the implementation*. This type is generated by the `cppwinrt.exe` tool in `\MyProject\MyProject\Generated Files\sources\MyRuntimeClass.h` and `MyRuntimeClass.cpp`.
- **MyRuntimeClass** is also the name of the projected type (that is, a wrapper over the runtime class for consumption purposes) in the form of the C++ struct `winrt::MyProject::MyRuntimeClass`. If there are separate implementing and consuming projects, then this struct exists in both. We'll call this type *the projected type*, or *the projection*. This type is generated by `cppwinrt.exe` in `\MyProject\MyProject\Generated Files\winrt\impl\MyProject.2.h`.

The implementation type looks like this.

```cppwinrt
// MyRuntimeClass.h
...
namespace winrt::MyProject::implementation
{
	struct MyRuntimeClass : MyRuntimeClassT<MyRuntimeClass>
	{
		MyRuntimeClass() = default;

		hstring Name();
		void Name(hstring const& value);
	};
}

// winrt::MyProject::factory_implementation::MyRuntimeClass is here, too.
```

And here are the parts of the projected type that are relevant to this topic.

```cppwinrt
// MyProject.2.h
...
namespace winrt::MyProject {
	struct MyRuntimeClass :
		MyProject::IMyRuntimeClass
	{
		MyRuntimeClass(std::nullptr_t) noexcept {}
		MyRuntimeClass();
	};
}
```

The point to take away from the listing above is that, in addition to any constructor(s) you declare in your IDL, the projected type has a constructor overload that takes `nullptr`. IDL-declared constructors are used to consume the runtime class from another compilation unit. The `nullptr` constructor is used to consume the runtime class from the same compilation unit. Later in this topic we'll say more about how to use these constructors, and we'll link to other topics with even more details about specific use cases.

> [!NOTE]
> If you want to consume your runtime class from another compilation unit (which is common), then include constructor(s) in your IDL (at least a default constructor). You'll also get a factory implementation alongside your implementation type.
> If you want to author and consume your runtime class only within the same 
compilation unit, and you need constructor parameters, then include constructor(s) in your IDL. You'll get a factory implementation, but you won't need it.
> Otherwise, you don't need a constructor in your IDL. Your implementation's default constructor will be deleted, but you can easily edit it and default it instead. You won't have a factory implementation (you don't need it), and the projection will only have the constructor overload that takes `nullptr`.

## Consuming a runtime class that's in a Windows namespace
This is the most common case in which you'll consume a runtime class. Here's a simple code example.

```cppwinrt
#include "winrt/Windows.Foundation.h"

using namespace winrt;
using namespace Windows::Foundation;

int main()
{
	init_apartment();

	Uri contosoUri{ L"http://www.contoso.com" };
}
```

We include the header `winrt/Windows.Foundation.h`, which contains the projected type for the runtime class [**Windows::Foundation::Uri**](/uwp/api/windows.foundation.uri?branch=live). And we construct the projected type via one of its publicly documented constructors ([**Uri(String)**](/uwp/api/windows.foundation.uri?branch=live#Windows_Foundation_Uri__ctor_System_String_), in this example). The publicly documented constructors are the IDL-defined constructors (*not* the `nullptr` constructor). That's all we have to do for this, very common, use case.

## Consuming a third-party runtime class
The next most common use case is consuming a third-party WinRT API.

If a third-party runtime class is implemented in a Windows Runtime Component and consumed from an app, then the implementation type and the consuming code are in different compilation units. In that case, the runtime class needs to be registered, and instantiated via WinRT/COM activation. You use `cppwinrt.exe` to generate a projected type from the component's Windows Metadata (`.winmd`). Then, just like with a Windows runtime class, you include a header and construct the projected type via one of its IDL-defined constructors (*not* the `nullptr` constructor). The consuming project's startup code registers the runtime class, and the projected type's constructor calls [RoActivateInstance](https://msdn.microsoft.com/library/br224646) to activate the runtime class from the referenced Windows Runtime component. For more details, code, and a walkthrough, see [Events; how to author and handle them in C++/WinRT](events-author-handle.md#create-a-core-app-bankaccountcoreapp-to-test-the-windows-runtime-component).

A third-party runtime class implemented in the same project as the consuming code doesn't need to be registered, nor instantiated via WinRT/COM activation. For this case, you use `cppwinrt.exe` to generate a projected type from the runtime class's Windows Metadata (`.winmd`). Then, you include a header and construct the projected type via its `nullptr` constructor. That constructor doesn't perform any initialization, so you must next assign a value to the instance via the [**winrt::make**](/uwp/cpp-ref-for-winrt/make?branch=live) free function. For more details, code, and a walkthrough, see [XAML controls; binding to a C++/WinRT property](binding-property.md#add-a-property-of-type-bookstoreviewmodel-to-mainpage).

## Authoring a third-party runtime class
For details, code, and a walkthrough of authoring a third-party runtime class in a Windows Runtime Component, [Events; how to author and handle them in C++/WinRT](events-author-handle.md).

For details, code, and a walkthrough of authoring a third-party runtime class in an app project, see [XAML controls; binding to a C++/WinRT property](binding-property.md).

If you're authoring a runtime class then, from within the same compilation unit, you can use the [**winrt::make_self**](/uwp/cpp-ref-for-winrt/make-self?branch=live) function  to construct an instance of the implementation type for the runtime class.

## Important APIs
* [winrt::make](/uwp/cpp-ref-for-winrt/make?branch=live)
* [winrt::make_self](/uwp/cpp-ref-for-winrt/make-self?branch=live)
